#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
"""
Time:
Author:
Description: vulnerability related database operation
"""
from time import time
import math
import json
from collections import defaultdict
from sqlalchemy.exc import SQLAlchemyError
from elasticsearch import ElasticsearchException

from aops_utils.log.log import LOGGER
from aops_utils.database.helper import sort_and_page, judge_return_code
from aops_utils.database.proxy import MysqlProxy, ElasticsearchProxy
from aops_utils.restful.status import DATABASE_DELETE_ERROR, DATABASE_INSERT_ERROR, NO_DATA, \
    DATABASE_QUERY_ERROR, DATABASE_UPDATE_ERROR, SUCCEED, PARAM_ERROR, SERVER_ERROR
from aops_utils.database.table import Host, User
from cve_manager.database.table import Cve, Task, TaskCveHostAssociation, TaskHostRepoAssociation, \
    CveTaskAssociation, CveHostAssociation, CveAffectedPkgs, CveUserAssociation
from cve_manager.conf.constant import TASK_INDEX
from cve_manager.function.customize_exception import EsOperationError


class TaskMysqlProxy(MysqlProxy):
    """
    Task related mysql table operation
    """

    def get_scan_host_info(self, username, host_list):
        """
        Query host info according to host id list.

        Args:
            username (str): user name
            host_list (list): host id list, can be empty

        Returns:
            list: host info, e.g.
                [
                    {
                        "host_id": "",
                        "host_ip": "",
                        "host_name": "",
                        "status": ""
                    }
                ]
        """
        result = []
        try:
            result = self._get_host_info(username, host_list)
            LOGGER.debug("Finished getting host info.")
            return result
        except SQLAlchemyError as error:
            LOGGER.error(error)
            LOGGER.error("Getting host info failed due to internal error.")
            return result

    def _get_host_info(self, username, host_list):
        """
        get info of the host id in host_list. If host list is empty, query all hosts
        """
        filters = {Host.user == username}
        if host_list:
            filters.add(Host.host_id.in_(host_list))

        info_query = self.session.query(Host.host_id, Host.host_name, Host.public_ip, Host.status) \
            .filter(*filters)

        info_list = []
        for row in info_query:
            host_info = {
                "host_id": row.host_id,
                "host_name": row.host_name,
                "host_ip": row.public_ip,
                "status": row.status
            }
            info_list.append(host_info)
        return info_list

    def get_total_host_info(self):
        """
        Get the whole host info of each user.
        Args:

        Returns:
            int: status code
            dict: query result
        """
        temp_res = {}
        result = {"host_infos": temp_res}

        try:
            users = self.session.query(User).all()
            for user in users:
                name = user.username
                temp_res[name] = []
                for host in user.hosts:
                    host_info = {
                        "host_id": host.host_id,
                        "host_name": host.host_name,
                        "host_ip": host.public_ip,
                        "status": host.status
                    }
                    temp_res[name].append(host_info)
            return SUCCEED, result
        except SQLAlchemyError as error:
            LOGGER.error(error)
            LOGGER.error("query host basic info fail")
            return DATABASE_QUERY_ERROR, result

    def init_host_scan(self, username, host_list):
        """
        When the host need to be scanned, init the status to 'scanning',
        and update the last scan time to current time.
        Notice, if one host id doesn't exist, all hosts will not be scanned
        Args:
            username (str): user name
            host_list (list): host id list, if empty, scan all hosts
        Returns:
            int: status code
        """
        try:
            status_code = self._update_host_scan("init", host_list, username)
            self.session.commit()
            LOGGER.debug("Finished init host scan status.")
            return status_code
        except SQLAlchemyError as error:
            self.session.rollback()
            LOGGER.error(error)
            LOGGER.error("Init host scan status failed due to internal error.")
            return DATABASE_UPDATE_ERROR

    def update_scan_status(self, host_list):
        """
        Every time a host or host list have been scanned, update the status to "done"

        Args:
            host_list (list): host id list

        Returns:
            int: status code
        """
        try:
            status_code = self._update_host_scan("finish", host_list)
            self.session.commit()
            LOGGER.debug("Finished updating host status after scanned.")
            return status_code
        except SQLAlchemyError as error:
            self.session.rollback()
            LOGGER.error(error)
            LOGGER.error("Updating host status after scanned failed due to internal error.")
            return DATABASE_UPDATE_ERROR

    def _update_host_scan(self, update_type, host_list, username=None):
        """
        Update hosts scan status and last_scan time
        Args:
            update_type (str): 'init' or 'finish'
            host_list (list): host id list
            username (str): user name
        Returns:

        """
        if update_type == "init":
            update_dict = {Host.status: "scanning", Host.last_scan: int(time())}
        elif update_type == "finish":
            update_dict = {Host.status: "done"}
        else:
            LOGGER.error("Given host scan update type '%s' is not in default type list "
                         "['init', 'finish']." % update_type)
            return SERVER_ERROR

        host_scan_query = self._query_scan_status_and_time(host_list, username)
        succeed_list = [row.host_id for row in host_scan_query]
        fail_list = set(host_list) - set(succeed_list)
        if fail_list:
            LOGGER.debug("No data found when setting the status of host: %s." % fail_list)
            if update_type == "init":
                return NO_DATA

        # update() is not applicable to 'in_' method without synchronize_session=False
        host_scan_query.update(update_dict, synchronize_session=False)
        return SUCCEED

    def _query_scan_status_and_time(self, host_list, username):
        """
        query host status and last_scan data of specific user
        Args:
            host_list (list): host id list, when empty, query all hosts
            username (str/None): user name
        Returns:
            sqlalchemy.orm.query.Query
        """
        filters = set()
        if host_list:
            filters.add(Host.host_id.in_(host_list))
        if username:
            filters.add(Host.user == username)

        hosts_status_query = self.session.query(Host.host_id, Host.status, Host.last_scan) \
            .filter(*filters)
        return hosts_status_query

    def save_scan_result(self, username, host_dict):
        """
        Save the scanned result to database.
        If one host id doesn't in Host table, then error will be raised and all insertion will
        be rolled back. So make sure Delete Host is forbidden during the scan.

        Args:
            username (str): username
            host_dict (dict): e.g.
                {
                    "id1": ["cve1", "cve2"],
                    "id2": [],
                }
        Returns:
            int
        """
        try:
            status_code = self._save_scan_result(username, host_dict)
            self.session.commit()
            LOGGER.debug("Finished saving scan result.")
            return status_code
        except SQLAlchemyError as error:
            self.session.rollback()
            LOGGER.error(error)
            LOGGER.error("Saving scan result failed due to internal error.")
            return DATABASE_INSERT_ERROR

    def _save_scan_result(self, username, host_dict):
        """
        Save host and cve's relationship into CveHostAssociation table.
        Delete the scanned hosts' previous cve record first, then add new cve record if
        cve list is not empty.

        Args:
            username (str): username
            host_dict (dict): record scanned hosts' cve list

        Returns:
            int
        """
        host_list = list(host_dict.keys())

        self.session.query(CveHostAssociation) \
            .filter(CveHostAssociation.host_id.in_(host_list)) \
            .delete(synchronize_session=False)

        exist_cve_query = self.session.query(Cve.cve_id)
        exist_cve_set = {row.cve_id for row in exist_cve_query}

        cve_host_rows = []
        valid_cve_set = set()
        for host_id, cve_list in host_dict.items():
            for cve_id in cve_list:
                if cve_id in exist_cve_set:
                    row = {"host_id": host_id, "cve_id": cve_id}
                    cve_host_rows.append(row)
                    valid_cve_set.add(cve_id)
                else:
                    LOGGER.debug("Cve '%s' in Scan result cannot be recorded because its data has "
                                 "not been imported yet." % cve_id)

        self.session.bulk_insert_mappings(CveHostAssociation, cve_host_rows)
        self._update_user_cve_status(username, valid_cve_set)
        return SUCCEED

    def _update_user_cve_status(self, username, cve_set):
        """
        update CveUserAssociation table, add new cve's record. If a cve doesn't exist in all
        hosts, still preserve it in the table
        Args:
            username (str): user name
            cve_set (set): the cve set to be added into CveUserAssociation table

        Returns:
            None
        """
        exist_cve_query = self.session.query(CveUserAssociation.cve_id) \
            .filter(CveUserAssociation.user_name == username)
        exist_cve = [row.cve_id for row in exist_cve_query]

        new_cve_list = list(cve_set-set(exist_cve))
        user_cve_rows = []
        for cve_id in new_cve_list:
            user_cve_rows.append({"cve_id": cve_id, "user_name": username,
                                  "status": "not reviewed"})
        self.session.bulk_insert_mappings(CveUserAssociation, user_cve_rows)

    def get_task_list(self, data):
        """
        Get the task list.
        Args:
            data (dict): parameter, e.g.
                {
                    "username": "admin",
                    "sort": "host_num",
                    "direction": "asc",
                    "page": 1,
                    "per_page": 10,
                    "filter": {
                        "task_name": "task2",
                        "task_type": ["repo"]
                    }
                }
        Returns:
            int: status code
            dict: query result. e.g.
                {
                    "total_count": 1,
                    "total_page": 1,
                    "result": [
                        {
                            "task_id": "id1",
                            "task_name": "task1",
                            "task_type": "cve",
                            "description": "a long description",
                            "host_num": 12,
                            "create_time": 1111111111
                        }
                    ]
                }
        """
        result = {}
        try:
            result = self._get_processed_task_list(data)
            LOGGER.debug("Finished getting task list.")
            return SUCCEED, result
        except SQLAlchemyError as error:
            LOGGER.error(error)
            LOGGER.error("Getting task list failed due to internal error.")
            return DATABASE_QUERY_ERROR, result

    def _get_processed_task_list(self, data):
        """
        Get sorted, paged and filtered task list.

        Args:
            data(dict): sort, page and filter info

        Returns:
            dict
        """
        result = {
            "total_count": 0,
            "total_page": 0,
            "result": []
        }

        filters = self._get_task_list_filters(data.get("filter"))
        task_list_query = self._query_task_list(data["username"], filters)

        total_count = len(task_list_query.all())
        if not total_count:
            return result

        sort_column = getattr(Task, data.get("sort")) if "sort" in data else None
        direction, page, per_page = data.get('direction'), data.get('page'), data.get('per_page')

        processed_query, total_page = sort_and_page(task_list_query, sort_column,
                                                    direction, per_page, page)

        result['result'] = self._task_list_row2dict(processed_query)
        result['total_page'] = total_page
        result['total_count'] = total_count

        return result

    def _query_task_list(self, username, filters):
        """
        query needed task list
        Args:
            username (str): user name of the request
            filters (set): filter given by user

        Returns:
            sqlalchemy.orm.query.Query
        """
        task_list_query = self.session.query(Task.task_id, Task.task_name, Task.task_type,
                                             Task.description, Task.host_num, Task.create_time) \
            .filter(Task.username == username) \
            .filter(*filters)
        return task_list_query

    @staticmethod
    def _task_list_row2dict(rows):
        result = []
        for row in rows:
            task_info = {
                "task_id": row.task_id,
                "task_name": row.task_name,
                "task_type": row.task_type,
                "description": row.description,
                "host_num": row.host_num,
                "create_time": row.create_time
            }
            result.append(task_info)
        return result

    @staticmethod
    def _get_task_list_filters(filter_dict):
        """
        Generate filters

        Args:
            filter_dict(dict): filter dict to filter cve list, e.g.
                {
                    "task_name": "task2",
                    "task_type": ["cve", "repo"]
                }

        Returns:
            set
        """
        filters = set()
        if not filter_dict:
            return filters

        if filter_dict.get("task_name"):
            filters.add(Task.task_name.like("%" + filter_dict["task_name"] + "%"))
        if filter_dict.get("task_type"):
            filters.add(Task.task_type.in_(filter_dict["task_type"]))
        return filters
